### Basic Ref Counting ###

def main() -> int {
    var obj: str = "A";
    INC(obj);

    _ret_ = test(obj, "B");
    CHECK(_ret_);

    DEC(obj);
    obj = "D";
    INC(obj);

    DEC(obj);

    return 0;
}


def test(obj1: str, obj2: str) -> str {
    INC(obj1);
    INC(obj2);

    var ret: str = obj1 + obj2;
    INC(ret);

    _ret_ = ret;
    INC(_ret_);

    DEC(obj1);
    DEC(obj2);
    DEC(ret);

    DEC_NO_CHECK(_ret);
    return ret;
}


### Better? Ref Counting ###

typdef struct {
    size_t capacity;
    size_t used;
    void** array;
} List;


List objs = { .capacity = 0, .used = 0, .array = NULL };

void aize_mem_add(obj: void*) {
    if (objs.capacity == objs.used) {
        if (objs.capacity == 0) {
            # initial allocation
            objs.capacity = 16;
        } else {
            objs.capacity *= 2;
        }
        objs.array = realloc(objs.array, sizeof(void*) * objs.capacity);
    }
    objs.array[objs.used++] = obj;
}

void aize_mem_pop(num: int) {
    memset(objs.used - num, 0, num);
    objs.used -= num;
    if (objs.used < objs.capacity / 4 and objs.capacity >= 64) {
        objs.capacity /= 4;
        objs.array = realloc(objs.array, sizeof(void*) * objs.capacity);
    }
}

int aize_depth = 0;

def aize_malloc(size_t size) {
    void* mem = malloc(size);
    aize_mem_add(mem);
    return mem;
}


void aize_mem_check() {
    size_t num = 0;
    size_t spared = 0;
    for (int i = objs.used; i >= 0; i--) {
        void* obj = objs.array[i];
        if (obj->depth > aize_depth) {
            if (objs.refs == 0) {
                free(obj);
                num++;
            } else {
                obj.depth -= 1;
                spared++;
                size_t new_size = objs.used-num;
                for (int j = 0; j < spared; j++) {
                    objs.array[new_size+j] = objs.array[objs.used-j];
                }
                aize_mem_pop(num);
                num = 0;
            }
        } else {
            break;
        }
    }
    aize_mem_pop(num);
}


def check_ref(obj: void*) {
    if (obj->ref == 0) {
        free(obj);
        aize_mem_pop(1);
    }
}


#define ENTER() depth += 1

#define RETURN_OBJ(obj) do { void* ret_obj = obj; ret_obj->ref += 1; check(); ret_obj->ref -= 1; return ret_obj; } while (0)

#define CHECK_OBJ(obj) check_obj(obj)

def ret_obj(obj) {
    obj.depth -= 1;
}


def main() -> str {
    ENTER();
    var obj: str = "A";

    _obj_ = test(obj, "B");
    CHECK_OBJ(_obj_);

    obj = "D";

    RETURN();

    return 0;
}


def test(obj1: str, obj2: str) -> str {
    ENTER();

    var ret: str = obj1 + obj2;

    RETURN_OBJ(ret);
}
