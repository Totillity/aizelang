trait Stringable<T> {
    def to_string(this: T) -> String;
}


class Person {
    has Stringable<Person> {
        def to_string(this: Person) -> String {
            return f"Person({this.name})"
        }
    }

    has Addable<Person, Person, Person> {
        def add(this: Person, other: Person) -> Person {
            return Person::mix(this, other);
        }
    }

    attr name: str;
}


def sum(li: List<V: Addable<V, V, V>>) -> V {
    v = li[0]
    for i in li.skip(1):
        addable = i.addable;
        v = v.add(addable)
    return v;
}


# auto gets if only 1 Stringable
def print(obj: ~Stringable) {
    io::write(obj.to_string() + "\n");
}


def main() -> int {
    var person: Person = Person::new("Jane");
    print(person);
}


### GENERATED C ###

enum TypeID {
    VECTOR = 0;
}


struct Stringable {
    void* to_string;
}


struct Stringable* Stringable_ttable[1] = {
    VECTOR: &((struct Stringable) { .to_string = Vector_to_string })
}


void* Vector_vtable[0] = { }

struct Vector {
    TypeID id;
}


void print(AizeBase obj) {
    Stringable_ttable[obj.id].to_string(obj)
}
